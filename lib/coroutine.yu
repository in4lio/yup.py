($! based on Simon Tatham "Coroutines in C")

($!
($coro-context A);
($coro-context B);

($coro-define A ]
	for ( ; ; ) {
		/* ... */
		($coro-yield);
	}
[ )

($coro-define B ]
	for ( ; ; ) {
		/* ... */
		($coro-yield);
	}
[ )

void main( void )
{
	for ( ; ; ) {
		($coro-call A);
		($coro-call B);
	}
}
)

($set __label_iter 0)

($macro coro-h ()
typedef void * co_t;
typedef unsigned int semaphore_t;

enum {
	CO_READY,
	CO_WAIT,
	CO_YIELD,
	CO_END,
	CO_SKIP,
};
)

($macro coro-context (name) co_t co_($name))

($macro coro-context-init (name) co_($name) = NULL)

($macro coro-declare (name) int coro_($name)( co_t *co_p ))

($set coro-define \name.\exit..\coro.\enter:[].\exit:[].]
($coro-declare ($name))
{
	($enter)
	if ( *co_p ) goto **co_p;
	/* begin */
	($coro exit)
	/* end */
	*co_p = &&L__END_($name);

	L__END_($name):
	($exit)
	return CO_END;
}
[\set )

($macro coro-yield ()
do { /* yield */
	($set __label (L__($emit __label_iter inc)))
	*co_p = &&($__label);
	($&exit)
	return CO_YIELD;

	($__label):;
} while ( 0 ))

($macro coro-wait (cond)
do { /* wait */
	($set __label (L__($emit __label_iter inc)))
	*co_p = &&($__label);

	($__label):
	if (!(($cond))) { /* cond */
		($&exit)
		return CO_WAIT;
	}
} while ( 0 ))

($macro coro-restart ()
do { /* restart */
	*co_p = NULL;
	($&exit)
	return CO_YIELD;
} while ( 0 ))

($macro coro-quit (name)
do { /* quit */
	*co_p = &&L__END_($name);
	($&exit)
	return CO_END;
} while ( 0 ))

($macro coro-call (name) coro_($name)( &co_($name) ))

($macro coro-alive (thr) (( ($thr) ) < CO_END ))

($macro coro-wait-coro (thr) ($coro-wait [!($coro-alive [($thr)])]))

($macro semaphore-init (name val) ($name) = ($val))

($macro semaphore-acquire (name)
do { /* acquire */
	($coro-wait (` ($name) > 0 ));
	--($name);
} while ( 0 ))

($macro semaphore-release (name)
do { /* release */
	++($name);
} while ( 0 ))
